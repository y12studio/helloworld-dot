/**
 * Substrate API Sidecar v1.
 * Substrate API Sidecar is a REST service that makes it easy to interact with blockchain nodes built using Substrate's FRAME framework.
 *
 * The version of the OpenAPI document: 1.0.0-oas3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import BlockIdentifiers from './BlockIdentifiers';
import ElectionStatus from './ElectionStatus';
import UnappliedSlash from './UnappliedSlash';

/**
 * The StakingProgress model module.
 * @module model/StakingProgress
 * @version 1.0.0-oas3
 */
class StakingProgress {
    /**
     * Constructs a new <code>StakingProgress</code>.
     * @alias module:model/StakingProgress
     */
    constructor() { 
        
        StakingProgress.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>StakingProgress</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/StakingProgress} obj Optional instance to populate.
     * @return {module:model/StakingProgress} The populated <code>StakingProgress</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new StakingProgress();

            if (data.hasOwnProperty('at')) {
                obj['at'] = BlockIdentifiers.constructFromObject(data['at']);
            }
            if (data.hasOwnProperty('activeEra')) {
                obj['activeEra'] = ApiClient.convertToType(data['activeEra'], 'String');
            }
            if (data.hasOwnProperty('forceEra')) {
                obj['forceEra'] = ApiClient.convertToType(data['forceEra'], 'String');
            }
            if (data.hasOwnProperty('nextActiveEraEstimate')) {
                obj['nextActiveEraEstimate'] = ApiClient.convertToType(data['nextActiveEraEstimate'], 'String');
            }
            if (data.hasOwnProperty('nextSessionEstimate')) {
                obj['nextSessionEstimate'] = ApiClient.convertToType(data['nextSessionEstimate'], 'String');
            }
            if (data.hasOwnProperty('unappliedSlashes')) {
                obj['unappliedSlashes'] = ApiClient.convertToType(data['unappliedSlashes'], [UnappliedSlash]);
            }
            if (data.hasOwnProperty('electionStatus')) {
                obj['electionStatus'] = ElectionStatus.constructFromObject(data['electionStatus']);
            }
            if (data.hasOwnProperty('idealValidatorCount')) {
                obj['idealValidatorCount'] = ApiClient.convertToType(data['idealValidatorCount'], 'String');
            }
            if (data.hasOwnProperty('validatorSet')) {
                obj['validatorSet'] = ApiClient.convertToType(data['validatorSet'], ['String']);
            }
        }
        return obj;
    }


}

/**
 * @member {module:model/BlockIdentifiers} at
 */
StakingProgress.prototype['at'] = undefined;

/**
 * `EraIndex` of the era being rewarded. 
 * @member {String} activeEra
 */
StakingProgress.prototype['activeEra'] = undefined;

/**
 * Current status of era forcing.
 * @member {module:model/StakingProgress.ForceEraEnum} forceEra
 */
StakingProgress.prototype['forceEra'] = undefined;

/**
 * Upper bound estimate of the block height at which the next active era will start. Not included in response when `forceEra.isForceNone`.
 * @member {String} nextActiveEraEstimate
 */
StakingProgress.prototype['nextActiveEraEstimate'] = undefined;

/**
 * Upper bound estimate of the block height at which the next session will start.
 * @member {String} nextSessionEstimate
 */
StakingProgress.prototype['nextSessionEstimate'] = undefined;

/**
 * Array of upcoming `UnappliedSlash` indexed by era.
 * @member {Array.<module:model/UnappliedSlash>} unappliedSlashes
 */
StakingProgress.prototype['unappliedSlashes'] = undefined;

/**
 * @member {module:model/ElectionStatus} electionStatus
 */
StakingProgress.prototype['electionStatus'] = undefined;

/**
 * Upper bound of validator set size; considered the ideal size. Not included in response when `forceEra.isForceNone`.
 * @member {String} idealValidatorCount
 */
StakingProgress.prototype['idealValidatorCount'] = undefined;

/**
 * Stash account IDs of the validators for the current session. Not included in response when `forceEra.isForceNone`.
 * @member {Array.<String>} validatorSet
 */
StakingProgress.prototype['validatorSet'] = undefined;





/**
 * Allowed values for the <code>forceEra</code> property.
 * @enum {String}
 * @readonly
 */
StakingProgress['ForceEraEnum'] = {

    /**
     * value: "ForceNone"
     * @const
     */
    "ForceNone": "ForceNone",

    /**
     * value: "NotForcing"
     * @const
     */
    "NotForcing": "NotForcing",

    /**
     * value: "ForceAlways"
     * @const
     */
    "ForceAlways": "ForceAlways",

    /**
     * value: "ForceNew"
     * @const
     */
    "ForceNew": "ForceNew"
};



export default StakingProgress;

